from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Tuple, Any, Union
from enum import Enum
import uuid
from datetime import datetime
import math

# ==================== ENUMS & BASE TYPES ====================

class TerminalType(Enum):
    CRIMP = "crimp"
    SOLDER = "solder"
    IDC = "idc"  # Insulation Displacement Contact
    SCREW = "screw"
    SPRING = "spring"

class WireType(Enum):
    SINGLE_CORE = "single_core"
    MULTI_CORE = "multi_core"
    SHIELDED = "shielded"
    TWISTED_PAIR = "twisted_pair"
    COAXIAL = "coaxial"

class ConnectionType(Enum):
    WIRE_TO_PIN = "wire_to_pin"
    SPLICE = "splice"
    DAIZY_CHAIN = "daisy_chain"
    GROUND = "ground"

@dataclass
class Point2D:
    x: float
    y: float
    
    def distance_to(self, other: Point2D) -> float:
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)

@dataclass
class Point3D:
    x: float
    y: float
    z: float
    
    def distance_to(self, other: Point3D) -> float:
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2 + (self.z - other.z)**2)

# ==================== WIRE CLASS ====================

@dataclass
class WireSegment:
    """A segment of wire between two points in 3D space"""
    start_point: Point3D
    end_point: Point3D
    length: float = field(init=False)
    
    def __post_init__(self):
        self.length = self.start_point.distance_to(self.end_point)

@dataclass
class Wire:
    """Represents a single wire in the harness system"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""  # e.g., "W1", "PWR_12V"
    signal_name: Optional[str] = None  # Functional signal name
    
    # Electrical properties
    wire_type: str = "single_core"
    cross_section: float = 0.5  # mm²
    color: str = "BLK"
    stripe_color: Optional[str] = None
    insulation_type: str = "PVC"
    max_current: float = 5.0  # Amps
    resistance_per_meter: float = 0.01  # Ohms/m
    
    # Geometry
    segments: List[WireSegment] = field(default_factory=list)
    routed_length: float = 0.0  # Actual routed 3D length
    cut_length: float = 0.0  # Manufacturing cut length (with service loops)
    bend_radius: float = 10.0  # Minimum bend radius in mm
    
    # Connections
    from_connection: Optional[ConnectionPoint] = None
    to_connection: Optional[ConnectionPoint] = None
    
    # Bundling
    bundle_id: Optional[str] = None
    position_in_bundle: Optional[Tuple[float, float]] = None  # (radius, angle) relative to bundle center
    
    def add_segment(self, start: Point3D, end: Point3D) -> None:
        segment = WireSegment(start, end)
        self.segments.append(segment)
        self.routed_length += segment.length
    
    def calculate_total_length(self) -> float:
        return sum(segment.length for segment in self.segments)
    
    def get_wire_path_points(self) -> List[Point3D]:
        """Returns all points along the wire path"""
        points = []
        if self.segments:
            points.append(self.segments[0].start_point)
            for segment in self.segments:
                points.append(segment.end_point)
        return points
    
    def calculate_voltage_drop(self, current: float) -> float:
        """Calculate voltage drop over the wire"""
        return current * self.resistance_per_meter * self.routed_length
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "signal_name": self.signal_name,
            "wire_type": self.wire_type,
            "cross_section": self.cross_section,
            "color": self.color,
            "stripe_color": self.stripe_color,
            "routed_length": self.routed_length,
            "cut_length": self.cut_length,
            "from_connection": self.from_connection.id if self.from_connection else None,
            "to_connection": self.to_connection.id if self.to_connection else None,
            "bundle_id": self.bundle_id,
        }

# ==================== CONNECTOR & PIN CLASSES ====================

@dataclass
class Pin:
    """Represents a single pin/cavity in a connector"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    number: str  # e.g., "A1", "12", "PIN5"
    name: Optional[str] = None  # Functional name
    
    # Electrical properties
    terminal_type: TerminalType = TerminalType.CRIMP
    wire_gauge_range: Tuple[float, float] = (0.25, 2.5)  # min, max in mm²
    current_rating: float = 10.0  # Amps
    
    # Physical properties
    position: Point2D = field(default_factory=lambda: Point2D(0, 0))  # Position in connector face
    sealing_type: Optional[str] = None  # e.g., "IP67"
    lock_mechanism: Optional[str] = None  # e.g., "secondary lock"
    
    # Connection
    connected_wire: Optional[Wire] = None
    
    def connect_wire(self, wire: Wire) -> bool:
        """Connect a wire to this pin if compatible"""
        if not self.wire_gauge_range[0] <= wire.cross_section <= self.wire_gauge_range[1]:
            return False
        self.connected_wire = wire
        return True
    
    def disconnect_wire(self) -> Optional[Wire]:
        """Disconnect wire from pin"""
        wire = self.connected_wire
        self.connected_wire = None
        return wire
    
    @property
    def is_occupied(self) -> bool:
        return self.connected_wire is not None

@dataclass
class Connector:
    """Represents a connector in the harness"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    part_number: str
    name: str
    manufacturer: str = ""
    
    # Physical properties
    housing_type: str = ""  # e.g., "rectangular", "circular"
    pin_count: int = 0
    gender: str = ""  # "male", "female", "socket", "plug"
    sealing_rating: str = ""  # e.g., "IP67"
    mounting_type: str = ""  # "panel_mount", "inline", "cable_mount"
    
    # Geometry
    position_3d: Point3D = field(default_factory=lambda: Point3D(0, 0, 0))
    orientation: Tuple[float, float, float] = (0, 0, 0)  # Euler angles
    outline_points: List[Point2D] = field(default_factory=list)  # 2D outline
    
    # Pins
    pins: Dict[str, Pin] = field(default_factory=dict)  # key: pin number
    
    # Connections
    branch_points: List[BranchPoint] = field(default_factory=list)
    
    def add_pin(self, pin: Pin) -> None:
        self.pins[pin.number] = pin
    
    def get_pin(self, pin_number: str) -> Optional[Pin]:
        return self.pins.get(pin_number)
    
    def get_available_pins(self) -> List[Pin]:
        return [pin for pin in self.pins.values() if not pin.is_occupied]
    
    def get_wires(self) -> List[Wire]:
        """Get all wires connected to this connector"""
        wires = []
        for pin in self.pins.values():
            if pin.connected_wire:
                wires.append(pin.connected_wire)
        return wires
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "part_number": self.part_number,
            "name": self.name,
            "pin_count": self.pin_count,
            "position": (self.position_3d.x, self.position_3d.y, self.position_3d.z),
            "connected_wires": len(self.get_wires()),
        }

# ==================== BRANCH POINT CLASS ====================

@dataclass
class BranchPoint:
    """Represents a point where a harness branches (split, merge, splice)"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    type: str = "split"  # "split", "merge", "splice", "tie_point"
    
    # Location
    position_3d: Point3D = field(default_factory=lambda: Point3D(0, 0, 0))
    position_2d: Optional[Point2D] = None  # For formboard layout
    
    # Physical properties
    protection_type: Optional[str] = None  # e.g., "heat_shrink", "tape"
    diameter: float = 0.0  # Bundle diameter at this point
    min_bend_radius: float = 0.0
    
    # Connections
    incoming_wires: List[Wire] = field(default_factory=list)
    outgoing_branches: List[Branch] = field(default_factory=list)
    
    # For splices
    splice_type: Optional[str] = None  # "crimp", "solder", "ultrasonic"
    splice_part_number: Optional[str] = None
    
    def add_incoming_wire(self, wire: Wire) -> None:
        self.incoming_wires.append(wire)
    
    def add_outgoing_branch(self, branch: Branch) -> None:
        self.outgoing_branches.append(branch)
    
    def get_total_incoming_wires(self) -> int:
        return len(self.incoming_wires)
    
    def get_total_outgoing_wires(self) -> int:
        total = 0
        for branch in self.outgoing_branches:
            total += len(branch.wires)
        return total
    
    def validate_wire_counts(self) -> bool:
        """Validate that wire counts match (conservation of wires)"""
        if self.type in ["split", "merge"]:
            incoming_count = self.get_total_incoming_wires()
            outgoing_count = self.get_total_outgoing_wires()
            return incoming_count == outgoing_count
        return True  # Splices can change wire counts

# ==================== BRANCH CLASS ====================

@dataclass
class Bundle:
    """A collection of wires running together in a branch"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    
    # Wires in this bundle
    wires: List[Wire] = field(default_factory=list)
    
    # Protection
    protection_type: str = "none"  # "conduit", "sleeving", "tape", "braiding"
    protection_part_number: Optional[str] = None
    
    # Geometry
    segments: List[WireSegment] = field(default_factory=list)  # Centerline path
    diameter: float = 0.0  # Calculated bundle diameter
    
    def add_wire(self, wire: Wire) -> None:
        wire.bundle_id = self.id
        self.wires.append(wire)
        self._update_diameter()
    
    def remove_wire(self, wire: Wire) -> None:
        if wire in self.wires:
            wire.bundle_id = None
            self.wires.remove(wire)
            self._update_diameter()
    
    def _update_diameter(self) -> None:
        """Calculate bundle diameter based on wire cross-sections"""
        if not self.wires:
            self.diameter = 0.0
            return
        
        # Simple calculation: sqrt(sum of wire areas) * packing factor
        total_area = sum(wire.cross_section for wire in self.wires)
        packing_factor = 1.3  # Accounts for air gaps and insulation
        self.diameter = 2 * math.sqrt(total_area * packing_factor / math.pi)
    
    def get_wire_by_color(self, color: str) -> List[Wire]:
        return [wire for wire in self.wires if wire.color == color]
    
    def get_length(self) -> float:
        """Return length of the longest wire in the bundle"""
        if not self.wires:
            return 0.0
        return max(wire.routed_length for wire in self.wires)

@dataclass
class Branch:
    """Represents a branch in the harness topology (edge in the graph)"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    
    # Graph structure
    from_point: Union[Connector, BranchPoint]
    to_point: Union[Connector, BranchPoint]
    
    # Contents
    bundles: List[Bundle] = field(default_factory=list)
    
    # Geometry
    length: float = 0.0  # Centerline length
    path_points: List[Point3D] = field(default_factory=list)  # Control points for routing
    
    # Properties
    is_protected: bool = False
    is_secured: bool = False  # Has cable ties/clamps
    
    def add_bundle(self, bundle: Bundle) -> None:
        self.bundles.append(bundle)
    
    def get_all_wires(self) -> List[Wire]:
        """Get all wires in all bundles of this branch"""
        wires = []
        for bundle in self.bundles:
            wires.extend(bundle.wires)
        return wires
    
    def get_wire_count(self) -> int:
        return sum(len(bundle.wires) for bundle in self.bundles)
    
    def calculate_branch_diameter(self) -> float:
        """Calculate maximum diameter along the branch"""
        if not self.bundles:
            return 0.0
        return max(bundle.diameter for bundle in self.bundles)
    
    def validate_bend_radius(self, path_radius: float) -> bool:
        """Check if bend radius is sufficient for all wires"""
        min_wire_radius = min(
            (wire.bend_radius for bundle in self.bundles for wire in bundle.wires),
            default=0.0
        )
        return path_radius >= min_wire_radius

# ==================== HARNESS TOPOLOGY MANAGER ====================

@dataclass
class ConnectionPoint:
    """Generic connection point that can be a pin or branch point"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    element: Union[Pin, BranchPoint]
    type: str  # "pin", "branch_point"
    
    @property
    def position(self) -> Point3D:
        if self.type == "pin":
            # For pin, use connector position
            return Point3D(0, 0, 0)  # Should be calculated from connector
        else:
            return self.element.position_3d

class HarnessTopology:
    """Manages the complete harness graph structure"""
    
    def __init__(self, name: str = ""):
        self.name = name
        self.connectors: Dict[str, Connector] = {}
        self.branch_points: Dict[str, BranchPoint] = {}
        self.branches: Dict[str, Branch] = {}
        self.wires: Dict[str, Wire] = {}
        
        # Graph representation
        self.graph: Dict[str, List[Tuple[str, Branch]]] = {}  # adjacency list
    
    def add_connector(self, connector: Connector) -> None:
        self.connectors[connector.id] = connector
        self.graph[connector.id] = []
    
    def add_branch_point(self, branch_point: BranchPoint) -> None:
        self.branch_points[branch_point.id] = branch_point
        self.graph[branch_point.id] = []
    
    def add_branch(self, branch: Branch) -> None:
        self.branches[branch.id] = branch
        
        # Update graph
        from_id = branch.from_point.id
        to_id = branch.to_point.id
        
        if from_id not in self.graph:
            self.graph[from_id] = []
        if to_id not in self.graph:
            self.graph[to_id] = []
        
        self.graph[from_id].append((to_id, branch))
        self.graph[to_id].append((from_id, branch))
    
    def add_wire(self, wire: Wire) -> None:
        self.wires[wire.id] = wire
    
    def connect_wire(self, wire: Wire, 
                    from_connector: Connector, from_pin: str,
                    to_connector: Connector, to_pin: str) -> bool:
        """Connect a wire between two pins"""
        from_pin_obj = from_connector.get_pin(from_pin)
        to_pin_obj = to_connector.get_pin(to_pin)
        
        if not from_pin_obj or not to_pin_obj:
            return False
        
        if from_pin_obj.is_occupied or to_pin_obj.is_occupied:
            return False
        
        # Connect wire to pins
        wire.from_connection = ConnectionPoint(
            id=from_pin_obj.id,
            element=from_pin_obj,
            type="pin"
        )
        wire.to_connection = ConnectionPoint(
            id=to_pin_obj.id,
            element=to_pin_obj,
            type="pin"
        )
        
        from_pin_obj.connect_wire(wire)
        to_pin_obj.connect_wire(wire)
        
        self.add_wire(wire)
        return True
    
    def find_path_between_connectors(self, connector1_id: str, connector2_id: str) -> List[Branch]:
        """Find the path (sequence of branches) between two connectors"""
        # Implement BFS or Dijkstra for shortest path
        visited = set()
        queue = [(connector1_id, [])]
        
        while queue:
            node_id, path = queue.pop(0)
            
            if node_id == connector2_id:
                return path
            
            if node_id not in visited:
                visited.add(node_id)
                
                for neighbor_id, branch in self.graph.get(node_id, []):
                    new_path = path + [branch]
                    queue.append((neighbor_id, new_path))
        
        return []
    
    def calculate_wire_lengths(self) -> None:
        """Calculate and update wire lengths based on branch paths"""
        for wire in self.wires.values():
            if wire.from_connection and wire.to_connection:
                # Find path through topology
                path = self.find_path_between_connectors(
                    wire.from_connection.id,
                    wire.to_connection.id
                )
                
                # Sum branch lengths
                total_length = sum(branch.length for branch in path)
                wire.routed_length = total_length
                
                # Add service loop percentage (typically 5-10%)
                wire.cut_length = total_length * 1.07
    
    def generate_harness_drawing_table(self) -> List[Dict]:
        """Generate manufacturing wire list"""
        table = []
        
        for wire in self.wires.values():
            from_info = ""
            to_info = ""
            
            if wire.from_connection and wire.from_connection.type == "pin":
                pin = wire.from_connection.element
                connector = self._find_connector_for_pin(pin.id)
                if connector:
                    from_info = f"{connector.name}:{pin.number}"
            
            if wire.to_connection and wire.to_connection.type == "pin":
                pin = wire.to_connection.element
                connector = self._find_connector_for_pin(pin.id)
                if connector:
                    to_info = f"{connector.name}:{pin.number}"
            
            table.append({
                "wire_id": wire.name,
                "from": from_info,
                "to": to_info,
                "color": wire.color,
                "cross_section": wire.cross_section,
                "length": wire.cut_length,
                "signal": wire.signal_name or ""
            })
        
        return table
    
    def _find_connector_for_pin(self, pin_id: str) -> Optional[Connector]:
        for connector in self.connectors.values():
            for pin in connector.pins.values():
                if pin.id == pin_id:
                    return connector
        return None
    
    def validate_topology(self) -> List[str]:
        """Validate the complete harness topology"""
        errors = []
        
        # Check for unconnected wires
        for wire in self.wires.values():
            if not wire.from_connection or not wire.to_connection:
                errors.append(f"Wire {wire.name} is not fully connected")
        
        # Check branch point wire conservation
        for branch_point in self.branch_points.values():
            if not branch_point.validate_wire_counts():
                errors.append(f"Branch point {branch_point.name} wire count mismatch")
        
        # Check for disconnected components
        visited = set()
        components = list(self.connectors.keys()) + list(self.branch_points.keys())
        
        if components:
            stack = [components[0]]
            while stack:
                node = stack.pop()
                if node not in visited:
                    visited.add(node)
                    for neighbor, _ in self.graph.get(node, []):
                        if neighbor not in visited:
                            stack.append(neighbor)
            
            disconnected = set(components) - visited
            for node in disconnected:
                errors.append(f"Disconnected component: {node}")
        
        return errors

# ==================== USAGE EXAMPLE ====================

def create_sample_harness() -> HarnessTopology:
    """Create a simple example harness"""
    harness = HarnessTopology("Engine Harness")
    
    # Create connectors
    ecu = Connector(
        part_number="AMP-123456",
        name="ECU",
        pin_count=4,
        gender="female"
    )
    
    sensor = Connector(
        part_number="TE-789012",
        name="Temperature Sensor",
        pin_count=2,
        gender="male"
    )
    
    # Add pins
    for i in range(1, 5):
        ecu.add_pin(Pin(number=str(i), name=f"ECU_PIN_{i}"))
    
    for i in range(1, 3):
        sensor.add_pin(Pin(number=str(i), name=f"SENSOR_PIN_{i}"))
    
    harness.add_connector(ecu)
    harness.add_connector(sensor)
    
    # Create a branch point (splice for ground)
    ground_splice = BranchPoint(
        name="GND Splice",
        type="splice",
        splice_type="crimp"
    )
    harness.add_branch_point(ground_splice)
    
    # Create branches
    branch1 = Branch(
        name="Main Trunk",
        from_point=ecu,
        to_point=ground_splice,
        length=500.0
    )
    
    branch2 = Branch(
        name="Sensor Branch",
        from_point=ground_splice,
        to_point=sensor,
        length=300.0
    )
    
    harness.add_branch(branch1)
    harness.add_branch(branch2)
    
    # Create wires
    power_wire = Wire(
        name="W1",
        signal_name="PWR_12V",
        cross_section=1.0,
        color="RED"
    )
    
    signal_wire = Wire(
        name="W2",
        signal_name="TEMP_SIGNAL",
        cross_section=0.5,
        color="BLU"
    )
    
    ground_wire1 = Wire(
        name="W3",
        signal_name="GND",
        cross_section=1.0,
        color="BLK"
    )
    
    ground_wire2 = Wire(
        name="W4",
        signal_name="GND",
        cross_section=1.0,
        color="BLK"
    )
    
    # Connect wires
    harness.connect_wire(power_wire, ecu, "1", sensor, "1")
    harness.connect_wire(signal_wire, ecu, "2", sensor, "2")
    harness.connect_wire(ground_wire1, ecu, "3", ground_splice, None)
    harness.connect_wire(ground_wire2, ground_splice, None, sensor, "3")
    
    # Add wires to bundles
    main_bundle = Bundle(name="Main Bundle")
    main_bundle.add_wire(power_wire)
    main_bundle.add_wire(signal_wire)
    main_bundle.add_wire(ground_wire1)
    branch1.add_bundle(main_bundle)
    
    sensor_bundle = Bundle(name="Sensor Bundle")
    sensor_bundle.add_wire(power_wire)
    sensor_bundle.add_wire(signal_wire)
    sensor_bundle.add_wire(ground_wire2)
    branch2.add_bundle(sensor_bundle)
    
    # Calculate lengths
    harness.calculate_wire_lengths()
    
    return harness

# Example usage
if __name__ == "__main__":
    harness = create_sample_harness()
    
    # Generate manufacturing table
    hdt = harness.generate_harness_drawing_table()
    print("Harness Drawing Table:")
    for row in hdt:
        print(f"  {row['wire_id']}: {row['from']} -> {row['to']}, {row['color']}, {row['length']:.1f}mm")
    
    # Validate
    errors = harness.validate_topology()
    if errors:
        print("\nValidation Errors:")
        for error in errors:
            print(f"  - {error}")
    else:
        print("\nTopology is valid!")
    
    # Print connector info
    print("\nConnectors:")
    for connector in harness.connectors.values():
        print(f"  {connector.name}: {len(connector.get_wires())} wires connected")